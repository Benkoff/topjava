Java Enterprise Online Project 
===============================

## ![hw](https://cloud.githubusercontent.com/assets/13649199/13672719/09593080-e6e7-11e5-81d1-5cb629c438ca.png) Домашнее задание HW0
```
Реализовать метод UserMealsUtil.getFilteredWithExceeded:
-  должны возвращаться только записи между startTime и endTime 
-  поле UserMealWithExceed.exceed должно показывать, 
                                     превышает ли сумма калорий за весь день параметра метода caloriesPerDay  
        
Т.е UserMealWithExceed - это запись одной еды, но поле exceeded будет одинаково для всех записей за этот день.
    
- Проверте результат выполнения ДЗ (можно проверить логику в http://topjava.herokuapp.com , список еды)
- Оцените Time complexity вашего алгоритма, если он O(N*N)- попробуйте сделать O(N).
```
Очевидно, существует множество различных вариантов решения поставленной задачи в рамках требуемой сложности O(N) (без вложенных циклов и рекурсии), но если не все, то большая их часть, сводятся к двум принципиальным схемам.
### Вариант 1: извлекая из входного потока все необходимые данные, получаем полную картину и на ее основе выстраиваем нужные нам конструкции.
  То есть, входной List<UserMeals> прогоняем сначала через первый stream, где получаем суммарные данные по каждому дню, заносим их в HashMap<Date, Calories>, затем вторым проходом преобразуем List<UserMeals> в List<UserMealWithExceed> через сравнение калорий в каждом приеме пищи с суммарным суточным из HashMap; результат фильтруем, получая на выходе список в заданных временных рамках.
  Для простоты сравнения дат в класс UserMeals не помешает добавить вспомогательный метод, возвращающий день в удобном формате:
```
  public LocalDate getDate() {
        return LocalDate.from(dateTime);
    }
```
  Сложность соединения двух потоков в одну конструкцию преодолевается использованием метода стандартного коллектора 
```
  public static <T,A,R,RR> Collector<T,A,RR> collectingAndThen(Collector<T,A,R> downstream, Function<R,RR> finisher)
```
Он позволяет добавить к первому коллектору дополнительную финишную обработку, которой и станет вторая обработка входного списка. В конечном итоге получим что то вроде:
```
  //первый проход по списку mealList
  return mealList
                .stream()
                .collect(
                        //сначала запускается сборщик(коллектор), а за ним последует финишная обработка
                        Collectors.collectingAndThen(
                                //собираем данные в набор пар ключ - "дата", значение - "сумма калорий"
                                Collectors.groupingBy(UserMeal::getDate,
                                        Collectors.summingInt(UserMeal::getCalories)),
                                //передаем HashMap дальше
                                map -> {
                                    //начинается второй проход, ранее заявленный как финишная обработка после первого сборщика
                                    return mealList
                                            .stream()
                                            //фильтруем список в заданных временных рамках
                                            .filter(x ->
                                                    TimeUtil.isBetween(LocalTime.from(x.getDateTime()), startTime, endTime))
                                            //преобразуем в UserMealWithExceed
                                            .map(x -> {
                                                return new UserMealWithExceed(
                                                        x.getDateTime(),
                                                        x.getDescription(),
                                                        x.getCalories(),
                                                        new Boolean(map.get(x.getDate()) > caloriesPerDay));
                                            })
                                            //собираем в итоговый список
                                            .collect(Collectors.toList());
                                }
                        ));
```
  Это как раз тот случай, когда мы сначала описываем, что хотим получить, а потом запускаем процесс вызовом терминальных операций. Именно то, что прекрасно реализуется при помощи "ленивых" вычислений Java 8 stream.

### Вариант 2: последовательно перебирая входной поток, приступаем к созданию фрагментов итогового списка, как только накопится минимально необходимый объем данных. 
  Процесс состоит из множества коротких последовательно повторяющихся операций - это позволяет отказаться от промежуточного хранилища в виде объемной HashMap, а для разграничения серий использовать естественные границы отсортированных данных. Каждый раз со сменой даты мы начинаем новую итерацию, читаем в буфер входящие объекты, в конце - суммируем калории за день, затем сравниваем с ограничением и выдаем "на гора" соответствующую порцию объектов итогового списка. Некое "скользящее окно", открывающееся и закрывающееся со сменой дня. Замена работы с HashMap сортировкой данных вызывает вопрос относительно эффективности такой замены, но позволяет получить простейшую реализацию одним традиционным циклом. К тому же, используемый, начиная с Java 7, алгоритм сортировки Timsort очень эффективен на уже частично сортированных данных, а именно такими мы и оперируем.<br>
  Как это часто бывает, где хорошо работают процедурные методы, функциональные оказываются не так удобны и требуют некоторых танцев с бубном. Или нужно выносить объявление и инициализацию переменных из непрерывного потока, где мы не можем их объявить в силу синтаксических ограничений Java 8 stream, или необходимо писать специальную реализацию коллектора, где также можно объявить и инициализировать текущую дату, сумму калорий за день и промежуточный буфер для хранения входных данных до смены даты.

```
public class SlidingCollector<T> implements Collector<T, List<List<T>>, List<List<T>>> {
    private List<UserMeal> bufferedList = new ArrayList<>();
    private LocalDate bufferedDate = LocalDate.of(1900, 1, 1);
    private int totalCaloriesPerDay;

    @Override
    public Supplier<List<List<T>>> supplier() {
        return ArrayList::new;
    }

    @Override
    public BiConsumer<List<List<T>>, T> accumulator() {
        //вытаскиваем данные из стрима в промежуточный буфер
    }
    
    @Override
    public Function<List<List<T>>, List<List<T>>> finisher() {
        //проверяем смену даты и считаем калории за день
    }
    
    @Override
    public BinaryOperator<List<List<T>>> combiner() {
        //фильтруем по временным рамкам startTime, endTime
        return new UserMealWithExceed(...);
    }

    @Override
    public Set<Characteristics> characteristics() {
        //ничего из этого: CONCURRENT, IDENTITY_FINISH, UNORDERED 
        return EnumSet.noneOf(Characteristics.class);
    }
    
}
```

TBC
